<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>nn</title>
</head>
<body>

<script>
/*

TODO: Добавить еще входной сигнал и узел в hidden layer

Сеть получает 3 входных сигнала: vodka, rain, friend, на основе которой вычисляет пойдет ли реципиент на вечеринку. Известно, что при если vodka и rain дают true одновременно, то он ни куда непойдёт не пойдет(он не может идти домой пьяным под дождём - может заблудится), при этом если все три входных сигнала совпадут реципиент все же пойдет ( он не опасается за то как добирется обратно, ведь друг сможет ему помочь найти путь)

*/

/* Входные сигналы */
var vodka = 1,
	rain = 1,
	friend = 1;

	console.log(vodka);
	console.log(rain);
	console.log(friend);

/* Активационная функция, определяет идет ли сигнал дальше через узел */
function activationFunction(x) {
	return (x >= 0.5 ? 1 : 0);
}

/* главная вычисляющая функция */
function predict(vodka ,rain, friend) {
	var inputs = [vodka ,rain, friend]; // Массив входных узлов

	var weightsInputToHidden1 = [0.25, 0.25, 0]; // Весы входящие в первый узел второго уровня
	var weightsInputToHidden2 = [0.5, -0.5, 0.5]; // Весы входящие во второй узeл второго уровня 
	var weightsInputToHidden = [weightsInputToHidden1, weightsInputToHidden2]; // Массив весов входящие в узлы второго уровня создается для последующей обработки функцией transferToHidden()

	var weightsHiddenToOutput = [-1, 1.5]; // Весы входящие в узел третьего уровня

	/* Вычисления на 2 уровне (hidden level) */
	var hiddenInput = transferToHidden(weightsInputToHidden, inputs); // Значения приходящие  на вход hidden layer
	console.log('hiddenInput: ' + hiddenInput);
	var hiddenOutput = hiddenInput.map(item => activationFunction(item)); // Значения выходящие из hidden layer (массив из 0 и 1, указывающий какие из нейронов будут посылать сигнал дальше)
	console.log('hiddenOutput: ' + hiddenOutput);

	/* Вычисления на 3 уровне (output) */
	var output = transferToLast(weightsHiddenToOutput, hiddenOutput) // Значения приходящие на вход 3 уровня
	console.log('output: ' + output);
	return activationFunction(output) == 1;
}

/* Функция для вычисления значений приходяших на hidden layer (массив из сумм произведений весов на значения входных узлов) */
function transferToHidden(weightsArr, activeNodesArr){
	return weightsArr.map((outerItem) => outerItem.map((innerItem, index) => innerItem * activeNodesArr[index]).reduce((item1, item2) => item1 + item2));
}

/* Функция для вычисления значений приходяших на результирующий узел (сумма произведений весов на значения входных узлов) */
function transferToLast(weightsArr, activeNodesArr){
	return weightsArr.map((innerItem, index) => innerItem * activeNodesArr[index]).reduce((item1, item2) => item1 + item2);
}

console.log(predict(vodka ,rain, friend));


</script>

</body>
</html>