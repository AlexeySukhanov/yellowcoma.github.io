<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>nn2</title>
</head>
<body>

<script>
/*

TODO: Добавить еще входной сигнал и узел в hidden layer

Сеть получает 3 входных сигнала: vodka, rain, friend, на основе которой вычисляет пойдет ли реципиент на вечеринку. Известно, что при если vodka и rain дают true одновременно, то он ни куда непойдёт не пойдет(он не может идти домой пьяным под дождём - может заблудится), при этом если все три входных сигнала совпадут реципиент все же пойдет ( он не опасается за то как добирется обратно, ведь друг сможет ему помочь найти путь)

*/

/* Входные сигналы */
var vodka = 1,
	rain = 1,
	friend = 0;
	console.log('Входные сигналы:');
	console.log('vodka: ' + vodka);
	console.log('rain: ' + rain);
	console.log('friend: ' + friend);
	console.log('');

/* Активационная функция, определяет идет ли сигнал дальше через узел */
function activationFunction(x) {
	return 1 / (1 + Math.exp(-x));
}

/* главная вычисляющая функция */
function predict(vodka ,rain, friend) {
	var inputs = [vodka ,rain, friend]; // Массив входных узлов

	var weightsFromFirst1 = [0.79, 0.44, 0.43]; // Весы входящие от первого слоя входящие в первый узел второго слоя
	var weightsFromFirst2 = [0.85, 0.43, 0.29]; // Весы входящие от первого слоя входящие во второй узел второго слоя
	var weightsFromFirst = [weightsFromFirst1, weightsFromFirst2]; // Массив весов от первого слоя входящих в узлы второго слоя создается для последующей обработки функцией transferToHidden()

	var weightsFromSecond = [0.5, 0.52]; // Весы от второго слоя входящие в узел третьего слоя

	/* Вычисления на 2 уровне (hidden level) */
	console.log('Получаем значения приходящие на вход second layer:');
	console.log('transferToHidden() RUN!...');
	var secondIn = transferToHidden(weightsFromFirst, inputs); // Получаем значения приходящие на вход second layer
	console.log('secondIn: ' + secondIn);
	console.log('');

	console.log('Получаем Значения выходящие из second layer:');
	console.log('activationFunction() RUN!...');
	var secondOut = secondIn.map(item => activationFunction(item)); // Получаем Значения выходящие из second layer
	console.log('secondOut: ' + secondOut);
	console.log('');

	/* Вычисления на 3 уровне (output) */
	console.log('Получаем значения приходящие на вход output layer:');
	console.log('transferToLast() RUN!...');
	var outputIn = transferToLast(weightsFromSecond, secondOut) // Значения приходящие на вход 3 уровня
	console.log('outputIn: ' + outputIn);
	console.log('');

	console.log('Получаем итоговое значение выходящее из output layer:');
	console.log('activationFunction() RUN!...');
	var outputOut = activationFunction(outputIn);
	return outputOut;
}

/* Функция для вычисления значений приходяших на hidden layer (массив из сумм произведений весов на значения входных узлов) */
function transferToHidden(weightsArr, activeNodesArr){
	return weightsArr.map((outerItem) => outerItem.map((innerItem, index) => innerItem * activeNodesArr[index]).reduce((item1, item2) => item1 + item2));
}

/* Функция для вычисления значений приходяших на результирующий узел (сумма произведений весов на значения входных узлов) */
function transferToLast(weightsArr, activeNodesArr){
	return weightsArr.map((innerItem, index) => innerItem * activeNodesArr[index]).reduce((item1, item2) => item1 + item2);
}

console.log('outputOut: ' + predict(vodka ,rain, friend));


</script>

</body>
</html>